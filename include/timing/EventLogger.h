/* ------------------------------------------------------------------- *
 * Copyright (c) 2017, AIT Austrian Institute of Technology GmbH.      *
 * All rights reserved. See file FMITerminalBlock_LICENSE for details. *
 * ------------------------------------------------------------------- */

/**
 * @file EventLogger.h
 * @author Michael Spiegel, michael.spiegel@ait.ac.at
 */

#ifndef _FMITERMINALBLOCK_TIMING_EVENT_LOGGER
#define _FMITERMINALBLOCK_TIMING_EVENT_LOGGER

#include "timing/Event.h"
#include "base/ApplicationContext.h"

#include <boost/log/sources/channel_logger.hpp>
#include <boost/log/attributes/mutable_constant.hpp>
#include <boost/log/expressions/keyword.hpp>
#include <boost/log/expressions/keyword_fwd.hpp>

#include <boost/thread/mutex.hpp>
#include <string>

namespace FMITerminalBlock 
{
	namespace Timing
	{
		/** 
		 * @brief Defines the position of the logged event
		 * @details The position is defined according to the program's intended 
		 * event flow stages. In future versions the encoding of this enumeration
		 * may only be extended but not changed. It is save to use the encoding 
		 * scheme in external programs.
		 */
		enum ProcessingStage
		{
			realTimeGeneration = 0, ///< After being generated by a real-time source
			prediction = 1, ///< After predicting the event by the model
			endOfDistribution = 2, ///< After distributing the event to its sinks
			beginOfDistribution = 3, ///< Before notifying the event listeners
			locationUndefined = -1 ///< Undefined location, should be used with care
		};

		/**
		 * @brief The event logger class provides the functionality of tracing the
		 * event execution
		 * @details The class provides some facade functions which hide the boost
		 * logging framework complexity. It adds some attributes used to evaluate 
		 * the real-time behavior of the application. The class may be instantiated
		 * several times. Each event processing unit may maintain it's own instance 
		 * individually. Although it is save to use the same logger instance by more
		 * than one thread, the function may only be called by a single thread.
		 */
		class EventLogger: 
			public boost::log::sources::channel_logger_mt< ProcessingStage >
		{
		public:

			/** @brief The property's name which holds the global log file-name */
			static const std::string PROP_FILE_NAME;

			/**
			 * @brief Default C'tor
			 */
			EventLogger(void);

			/**
			 * @brief Globally adds a file sink which logs common event timing
			 * information
			 * @details <p> The sink's filename is taken from the given configuration.
			 * If it is not set or if it is set to an empty string, no sink will be 
			 * registered. The added sink will log information collected by all
			 * EventLogger instances. If the configuration is invalid, a
			 * Base::SystemConfigurationException will be thrown. </p>
			 * <p>The file will be written in a CSV-like format. Each field will be 
			 * separated by a single semicolon (;) and no header line will be written. 
			 * The fields written are:
			 * <ul>
			 *   <li>Number of the current weekday starting with Sunday = 0</li>
			 *   <li>The log record's hour. [0-23]</li>
			 *   <li>The log record's minute. [0-59]</li>
			 *   <li>The log record's second. [0.0-60.0)</li>
 			 *   <li>The logged event time-stamp. </li>
 			 *   <li>The number of the event stage. </li>
			 *   <li>Some Arbitrary debug information which may not be properly
			 *       escaped. The debug information field lasts until the next line
			 *       delimiter is reacher.</li>
			 * </ul>
			 * </p>
			 * @param context The application context used to obtain the configuration
			 * information.
			 */
			static void addEventFileSink(const Base::ApplicationContext& context);

			/**
			 * @brief Sets the time logging epoch for recording time events.
			 * @details The epoch is considered the point in time where a simulation
			 * time which equals zero is reached. In real time simulations, the 
			 * simulation is synchronized with this point in time. In non real-time 
			 * simulations, the time stamp is used to mark the start of any 
			 * processing activity. In case only a coarse evaluation is required, the
			 * default value which date to the time where the code is initialized may
			 * be taken.
			 *
			 * It was chosen to introduce a global simulation epoch since the 
			 * software currently only deploys a single time base. Consequently, the
			 * distribution of logger objects may be kept simple.
			 *
			 * The function is not thread save and must only be called in case no 
			 * other instance uses the time logging facility. Usually, the function 
			 * is called on startup and hence, the guarantee holds.
			 */
			static void setGlobalSimulationEpoch(boost::system_time simulationEpoch);

			/**
			 * @brief Logs the given event
			 * @details It is assumed that the given event reference is valid until
			 * the function returns
			 * @param ev The reference to the recorded event
			 * @param stage The current stage of the given event
			 */
			void logEvent(Event * ev, ProcessingStage stage);

		private:

			/** 
			 * @brief The timestamp of the logging facility which corresponds to a 
			 * simulation time which equals zero.
			 */
			static boost::system_time simulationEpoch_;

			/** @brief Mutex used to synchronize concurrent object access */
			boost::mutex objectMutex_;

			/** @brief Attribute used to log an event's time. */
			boost::log::attributes::mutable_constant<fmiTime> eventTimeAttribute_;
			/** @brief Attribute used to log the external time stamp of a record. */
			boost::log::attributes::mutable_constant<fmiTime> recordTimeAttribute_;

			/**
			 * @brief Returns the absolute time stamp now
			 * @details The same time base as simulationEpoch_ will be used. Hence, 
			 * the function provides a unique clock handling for time logging and 
			 * eliminates the possibility of different clock systems. Please avoid 
			 * querying the current time manually. (Although it is quite easy)
			 */
			static boost::system_time getAbsoluteRecordTimeNow();

			/** 
			 * @brief Returns the number of seconds since simulation epoch in a 
			 * floating point format.
			 */
			static fmiTime getRelativeRecodTimeNow();
		};
	}
}

#endif
